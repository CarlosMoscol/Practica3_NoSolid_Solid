<h2> Hi, Practica 3! <img src="https://i.imgur.com/jbvlrax.gif" width="50"></h2>

<!--# SRP-->
# Principio de responsabilidad √∫nica (SRP)
## Pregunta 1
<!--# ### Muestra la salida y explica los resultados en funci√≥n de los m√©todos entregados-->
- **Muestra la salida y explica los resultados en funci√≥n de los m√©todos entregados**
	- El m√©todo displayEmpDetail() nos muestra para el primer empleado su lastName abejita seguido de su fristName Jessica, para el segundo empleado su lastName es Smart seguido de su fristName Chalito. ‚ù§Ô∏è
	
	- El m√©todo generateEmpId() concatena la primera palabra del firstName con un n√∫mero aleatorio (Los 1000 primeros) para formar una identificaci√≥n del empleado. En la ejecuci√≥n, dentro del m√©todo main() (el c√≥digo del cliente) se crea dos instancias de Empleado y se usa estos m√©todos para mostrar los detalles relevantes.
	Para el primer empleado obtenemos el ID J950 y para el segundo empleado el ID C147.
	
	- El m√©todo checkSeniority() eval√∫a si un empleado es una persona mayor. Se establece que si el empleado tiene m√°s de 5 a√±os de experiencia, es un empleado senior; de lo contrario, es un empleado Junior.
	Para el primer empleado es Senior y el segundo empleado es Junior.

<img src="https://github.com/CarlosMoscol/Practica3_NoSolid_Solid/blob/master/PruebasImagenes/SRP_Pregunta1.png">


## Pregunta 2
- **¬øCu√°l es el problema con este dise√±o y las razones posibles del problema?**

El problema es que no se esta cumpliendo con el SRP aqu√≠. Al mostrar los detalles de un empleado, generar una identificaci√≥n de empleado o verificar un nivel de antig√ºedad son actividades diferentes. Dado que se codifico todo en una sola clase, es posible que tenga problemas para adoptar nuevos cambios en el futuro.

Aqu√≠ hay algunos posibles razones:

üëã En un futuro se puede establecer un criterio diferente para decidir si un empleado es Senior o Junior e inclusive se podria agregar otra categoria como Master, por parte de la empresa.

üëã Tambi√©n se pueden el modificar el algoritmo para generar la identificaci√≥n del empleado.


## Pregunta 3
- **Modifica la clase Empleado. Agrega dos clases SeniorityChecker que contiene el m√©todo checkSeniority() y la clase GeneradorIDEmpleado contiene el m√©todo generateEmpId(...) para generar la identificaci√≥n del empleado. 
Para mejorar la legibilidad del c√≥digo y evitar torpezas dentro del m√©todo main(), utiliza el m√©todo est√°tico showEmpDetail(...). Este m√©todo llama al m√©todo displayEmpDetail() de Empleado, al m√©todo generateEmpId() de GeneradorIDEmpleado y al m√©todo checkSeniority() de SeniorityChecker. T√∫ entiendes que este m√©todo no era necesario, pero hace que el c√≥digo del cliente sea simple y f√°cilmente comprensible.**

 Agregamos la clase SeniorityChecker con el metodo checkSeniority
```java
public class SeniorityChecker {
    public String checkSeniority(double experienceInYears){
        return experienceInYears > 5 ?"senior":"junior";
    }
}
```

 Agregamos la clase GeneradorIDEmpleado con el metodo generateEmpId()
```java
import java.util.Random;

public class GeneradorIDEmpleado {
    String empId;
    public String generateEmpId(String empFirstName) {
        int random = new Random().nextInt(1000);
        empId = empFirstName.substring(0, 1) + random;
        return empId;
    }
}
```

Tenemos la clase Empleado
```java
public class Empleado {
    public String firstName, lastName, empId;
    public double experienceInYears;
    public Empleado(String firstName, String lastName, double experience) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.experienceInYears = experience;
    }
    public void displayEmpDetail(){
        System.out.println("Nombre del empleado: "+lastName+","+firstName);
        System.out.println("Este empleado tiene "+ experienceInYears+" a√±os de experiencia.");
    }
}
```

En el m√©todo main() de Cliente, se utiliza el m√©todo est√°tico showEmpDetail(...). Este m√©todo llama al m√©todo displayEmpDetail() de Empleado, al m√©todo generateEmpId() de GeneradorIDempleado y al m√©todo checkSeniority() de SeniorityChecker.

```java
public class Cliente {
    public static void main(String[] args) {
        System.out.println("Demostracion de SRP");

        Empleado jessica = new Empleado("Jessica", "Abejita", 7.5);
        showEmpDetail(jessica);

        System.out.println("\n*******\n");

        Empleado chalo = new Empleado ("Chalito", "Smart", 3.2);
        showEmpDetail(chalo);

    }

    private static void showEmpDetail(Empleado emp) {
        // Muestra detalles del empleado
        emp.displayEmpDetail();

        //Genera el ID
        GeneradorIDEmpleado idGenerador = new GeneradorIDEmpleado();
        String empId=idGenerador.generateEmpId(emp.firstName);
        System.out.println("El ID del empleado es: " + empId);

        // Verifica el nivel laboral
        SeniorityChecker seniorityChecker = new SeniorityChecker();
        System.out.println("Este empleado es un" + " empleado " + seniorityChecker.checkSeniority(emp.experienceInYears));
    }
}
```


## Pregunta 4
- **Realiza una demostraci√≥n completa que sigue a SRP. Explica tus resultados**


Notamos que los resultados obtenidos son similares a los resultados de No Solid. Se comprende que el m√©todo showEmpDetail() de la clase empleado no es necesario, pero hace que el codigo del cliente sea mas simple y facilmente comprensible.

Ademas se debe tener en cuenta que SRP no dice que una clase deba tener como maximo un metodo. El enfasis esta en la responsabilidad √∫nica. Pueden haber m√©todos estrechamente relacionados que pueden ayudar a impletar dicha resposabilidad.

Por ejemplo podemos colocar todos los m√©todos de visualizaci√≥n en una sola clase como se realiza en la clase cliente, la cual nos permite mostrar el nombre del empleado, los a√±os de experiencia, el ID del empleado y si un empleado es Senior o Junior.

<img src="https://github.com/CarlosMoscol/Practica3_NoSolid_Solid/blob/master/PruebasImagenes/SRP_Pregunta4.png">





<!--# OCP-->
# Principio abierto/cerrado (OCP)
## Pregunta 5
- **¬øPor que no es correcto colocar displayResult() y evaluateDistinction() en la misma clase, como la siguiente:**
```java
class Estudiante { 
	// ‚Ä¶. 
	public void displayResult() { 
		// codigo 
	} 
	public void evaluateDistinction() { 
		// codigo 
	} 
	// ‚Ä¶ 
} 
```

## Pregunta 6
- **Muestra la salida y explica los resultados en funci√≥n de los m√©todos entregados**

## Pregunta 7
- **¬øCu√°l es el problema con este dise√±o y las razones posibles del problema?. Para abordar este problema, puedes escribir un mejor programa.**

## Pregunta 8
- **Debes abordar el m√©todo de evaluaci√≥n para la distinci√≥n de una mejor manera. Por lo tanto, crea la interfaz DistinctionDecider que contiene un m√©todo llamado EvaluationDistinction.**


## Pregunta 9
- **Completa el c√≥digo de ArtsDistinctionDecider y ScienceDistinctionDecider que implementan esta interfaz y sobreescriben el m√©todo de evaluateDistinction(...) para especificar los criterios de evaluaci√≥n seg√∫n sus necesidades. De esta forma, los criterios de distinci√≥n espec√≠ficos de flujo se envuelven en una unidad independiente. 
Debes tener en cuenta que el m√©todo de evaluateDistinction(...) acepta un par√°metro Estudiante. Significa que ahora tambi√©n puede pasar un objeto ArtsStudent o un objeto ScienceStudent a este m√©todo.**
 
## Pregunta 10
- **Realiza una demostraci√≥n completa que sigue a OCP. Explica tus resultados**


## Pregunta 11
- **¬øCu√°les son las principales ventajas ahora?**

<!--# LSP-->
# Principio de sustituci√≥n de Liskov (LSP)
## Pregunta 12
- **Muestra la salida y explica los resultados en funci√≥n de los m√©todos entregados**

## Pregunta 13
- **Ahora supongamos que tienes un nuevo requisito que dice que necesitas admitir
usuarios invitados en el futuro. Puedes procesar la solicitud de pago de un usuario invitado,
pero no muestra su √∫ltimo detalle de pago. Entonces, crea la siguiente clase que implementa la
interfaz de pago de la siguiente manera:**
```java
class GuestUserPayment implements Payment {
	String name;
	public GuestUserPayment() {
		this.name = "guest";
	}
	@Override
	public void previousPaymentInfo(){
		throw new UnsupportedOperationException();
	}
	@Override
	public void newPayment(){
		System.out.println("Procesando de "+name+ "pago actual request.");
	}
}
```

## Pregunta 14
- **Dentro del m√©todo main(), utilizas una instancia de usuario invitado e intentas
  usar su clase auxiliar de la misma manera,¬ø qu√© tipo de excepci√≥n te encuentras?¬øCu√°l es la
  soluci√≥n?**

## Pregunta 15
- **Todo lo anterior Lo m√°s importante es que viola el OCP cada vez que modifica una
  clase existente que usa esta cadena if-else. Entonces, busquemos una mejor soluci√≥n.**

## Pregunta 16
**En el pr√≥ximo programa, eliminaremos el m√©todo newPayment() de la interfaz de
  payment. Coloca este m√©todo en otra interfaz llamada NewPayment. Como resultado, ahora
  tienes dos interfaces con las operaciones espec√≠ficas. Dado que todos los tipos de usuarios
  pueden generar una nueva solicitud de pago, las clases concretas de RegisteredUserPayment y
  GuestUserPayment implementan la interfaz NewPayment.**

**Pero muestra el √∫ltimo detalle de pago solo para los usuarios registrados. Entonces, la clase
  RegisteredUser implementa la interfaz payment. Dado que Payment contiene el m√©todo
  previousPaymentInfo(), tiene sentido elegir un nombre mejor, como PreviousPayment en lugar
  de Payment. Entonces, ahora ver√° las siguientes interfaces:**

```java
interface PreviousPayment {
	void previousPaymentInfo();
}
interface NewPayment {
	void newPayment();
}
```
**Ajuste estos nuevos nombres en la clase auxiliar tambi√©n. En secci√≥n del c√≥digo debes tener los siguientes archivos:**
- PreviousPayment.java
- NewPayment.java
- RegisteredUserPayment.java
- GuestUserPayment.java
- PaymentHelper.java
- Cliente.java


## Pregunta 17
- **¬øCu√°les son los cambios clave?**


## Pregunta 18
- **Ten que aqu√≠ el enfoque clave estaba en el principio LSP, nada m√°s. Podr√≠as
  refactorizar f√°cilmente el c√≥digo del cliente usando alg√∫n m√©todo est√°tico. Por ejemplo realiza
  una modificaci√≥n donde utilizas un m√©todo est√°tico para mostrar todas las solicitudes de pago
  y utilizar este m√©todo siempre que lo necesites.**

<!--# ISP-->
# Principio de segregaci√≥n de interfaz (ISP)
## Pregunta 19
- **¬øPor qu√© un usuario necesita cambiar una clase base (o una interfaz)? Para
  responder a esto, supongamos que deseas mostrar qu√© el tipo de fax est√° utilizando en una fase
  de desarrollo posterior.**
**Tu sabes que existen diferentes variaciones de m√©todos de fax, como LanFax, InternetFax (o
  EFax) y AnalogFax. Entonces, antes, el m√©todo SendFax() no usaba ning√∫n par√°metro, pero
  ahora necesita aceptar un par√°metro para mostrar el tipo de fax que usa. Escribe una jerarqu√≠a
  de fax que puede parecerse a la siguiente:**
```java
interface Fax {
// codigo
}
class LanFax implements Fax {
	@Override
// codigo
}
class EFax implements Fax {
	@Override
// codigo
}
```

## Pregunta 20
- **Para usar esta jerarqu√≠a de herencia, una vez que modificas el m√©todo sendFax() a
  sendFax(Fax faxType) en la clase ImpresoraAvanzada, exige que cambies la interfaz de
  Impresora (s√≠, aqu√≠ tambi√©n rompe el OCP).**
- **Cuando actualices Impresora, tambi√©n debes actualizar la clase impresoraBasica para
  adaptarse a este cambio. ¬°Ahora ves el problema!. Explica el problema.**

## Pregunta 21
- **Si has entendido correctamente el problema. El ISP te sugiere que te ocupes de
  este tipo de escenario. Explica tu respuesta.**

## Pregunta 22
- **¬øEs conveniente usar e inicializar el siguiente c√≥digo?**
```java
interface Impresora {
	void printDocument();
	void sendFax();
}
```
## Pregunta 23
- **Si comienzas tu codificaci√≥n considerando las impresoras avanzadas que pueden
  imprimir y enviar un fax, est√° bien. Pero en una etapa posterior, si tu programa tambi√©n
  necesita admitir impresoras b√°sicas,¬ø qu√© c√≥digo puedes escribir?**
- **¬°Ya has visto que este c√≥digo puede causarte un problema potencial!**
- **Est√° bastante claro que una impresora b√°sica no necesita enviar un fax. Pero dado que
  ImpresoraBasica implementa Impresora, debe proporcionar una implementaci√≥n de sendFax().
  Como resultado, cuando sendFax() cambia en la interfaz Impresora, ImpresoraBasica necesita
  adaptarse al cambio. El ISP sugiere que evites este tipo de situaciones.**
- **En este contexto, Cuando lanzas la excepci√≥n e intentas usar c√≥digo polim√≥rfico de manera
  incorrecta, ves el impacto de violar el LSP. Una vez que modificas Impresora, tambi√©n viola el
  OCP.**

## Pregunta 24
- **Comprueba tus respuestas a√±adiendo dentro de main(), el siguiente c√≥digo
  polim√≥rfico:**
```java
Impresora impresora = new ImpresoraAvanzada();
impresora.printDocument();
impresora.sendFax();
impresora = new ImpresoraBasica();
impresora.printDocument();
//impresora .sendFax();
```
#### Nota: Adem√°s, no puedes escribir algo como:
```java
List<Impresora> impresoras = new ArrayList<Impresora>();
impresoras.add(new ImpresoraAvanzada());
impresoras.add(new ImpresoraBasica());
for (Impresora dispositivo : impresoras) { .printDocument();
	// dispositivo.sendFax();
}
```
#### En ambos casos, ver√°s excepciones de tiempo de ejecuci√≥n.
## Pregunta 25

## Pregunta 26

## Pregunta 27

## Pregunta 28

## Pregunta 29

## Pregunta 30


<!--# DIP-->
# Principio de inversi√≥n de dependencia (DIP)
## Pregunta 31

## Pregunta 32

## Pregunta 33

## Pregunta 34

## Pregunta 35

## Pregunta 36

